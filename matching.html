<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>デートに行ってみたいマッチングアプリ</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #f0f4f8, #d9e2ec);
            color: #334155;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow-x: hidden;
        }
        .container {
            background: linear-gradient(145deg, #ffffff, #f0f4f8);
            border-radius: 20px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            padding: 40px;
            max-width: 550px;
            width: 95%;
            text-align: center;
            position: relative;
            overflow: hidden;
            border: 1px solid rgba(0, 0, 0, 0.05);
        }
        .screen {
            display: none;
            animation: fadeIn 0.6s ease-out;
        }
        .screen.active {
            display: block;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .btn-primary {
            @apply bg-gradient-to-r from-purple-600 to-indigo-700 text-white font-bold py-4 px-8 rounded-xl shadow-lg hover:from-purple-700 hover:to-indigo-800 transition-all duration-300 transform hover:scale-105;
        }
        .btn-secondary {
            @apply bg-gray-300 text-gray-800 font-bold py-4 px-8 rounded-xl shadow-md hover:bg-gray-400 transition-all duration-300 transform hover:scale-105;
        }
        .btn-danger {
            @apply bg-red-600 text-white font-bold py-3 px-6 rounded-xl shadow-md hover:bg-red-700 transition-all duration-300;
        }
        .input-field {
            @apply w-full p-3 border border-gray-400 rounded-xl bg-white text-gray-800 focus:ring-2 focus:ring-purple-500 focus:border-transparent transition-all duration-200;
        }
        .label-text {
            @apply block text-left text-gray-700 font-semibold mb-2;
        }
        .checkbox-container {
            @apply flex items-center justify-between p-4 bg-gray-100 rounded-xl shadow-sm mb-3 cursor-pointer hover:bg-gray-200 transition-colors duration-200;
        }
        .checkbox-container input[type="checkbox"] {
            @apply h-6 w-6 text-purple-500 rounded-md border-gray-400 focus:ring-purple-500;
        }
        .pachinko-reel-container {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 180px;
            overflow: hidden;
            border: 5px solid #fcd34d;
            border-radius: 20px;
            background-color: #000;
            margin-top: 30px;
            position: relative;
            box-shadow: 0 0 20px rgba(252, 211, 77, 0.6);
        }
        .pachinko-reel {
            font-size: 100px;
            font-weight: bold;
            color: #fcd34d;
            line-height: 1;
            animation: spinReel 1s ease-out forwards;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            text-shadow: 0 0 10px rgba(252, 211, 77, 0.8);
        }
        .pachinko-reel.active {
            opacity: 1;
        }
        @keyframes spinReel {
            0% { transform: translate(-50%, -50%) translateY(-150px) rotateX(90deg); opacity: 0; }
            50% { opacity: 1; }
            100% { transform: translate(-50%, -50%) translateY(0) rotateX(0deg); opacity: 1; }
        }
        .pachinko-reel-final {
            font-size: 120px;
            font-weight: bold;
            color: #fcd34d;
            animation: finalReveal 0.8s ease-out forwards;
            text-shadow: 0 0 20px rgba(252, 211, 77, 1);
        }
        @keyframes finalReveal {
            0% { transform: scale(0.5); opacity: 0; }
            70% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1001;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease-out;
        }
        .modal-overlay.active {
            opacity: 1;
            pointer-events: all;
        }
        .modal-content {
            background: linear-gradient(145deg, #ffffff, #f0f4f8);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            text-align: center;
            max-width: 450px;
            width: 90%;
            transform: translateY(-20px);
            transition: transform 0.3s ease-out;
            border: 1px solid rgba(0, 0, 0, 0.05);
        }
        .modal-overlay.active .modal-content {
            transform: translateY(0);
        }
        .text-gradient {
            background: linear-gradient(45deg, #a78bfa, #f472b6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .icon {
            display: inline-block;
            width: 24px;
            height: 24px;
            vertical-align: middle;
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Confirmation Modal -->
        <div id="confirmationModal" class="modal-overlay">
            <div class="modal-content">
                <p id="modalMessage" class="text-xl font-semibold mb-6 text-gray-800"></p>
                <div class="flex justify-around gap-4">
                    <button id="modalConfirmBtn" class="btn-primary flex-1">はい</button>
                    <button id="modalCancelBtn" class="btn-secondary flex-1">いいえ</button>
                </div>
            </div>
        </div>

        <!-- 1. 設定画面 -->
        <div id="settingsScreen" class="screen active">
            <h2 id="settingsScreenTitle" class="text-3xl font-bold mb-8 text-gradient"></h2>

            <div class="mb-6">
                <label for="customAppNameInput" class="label-text">マッチングテーマ</label>
                <input type="text" id="customAppNameInput" placeholder="例: 友情マッチング" class="input-field">
            </div>

            <div class="mb-6">
                <label for="maxCrushes" class="label-text">選択可能人数</label>
                <select id="maxCrushes" class="input-field">
                    <option value="1">1人</option>
                    <option value="2">2人</option>
                    <option value="3">3人</option>
                    <option value="4">4人</option>
                    <option value="5">5人</option>
                </select>
            </div>

            <div class="mb-6">
                <label class="label-text flex items-center justify-between">
                    <span>あなたに一方的にマッチングしたい人を表示する</span>
                    <label class="relative inline-flex items-center cursor-pointer">
                        <input type="checkbox" id="showUnrequitedCrushesToggle" class="sr-only peer">
                        <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-purple-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border after:border-gray-300 after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-purple-600"></div>
                    </label>
                </label>
            </div>

            <div class="mb-8">
                <label class="label-text flex items-center justify-between">
                    <span>ミュート</span>
                    <label class="relative inline-flex items-center cursor-pointer">
                        <input type="checkbox" id="muteToggle" class="sr-only peer">
                        <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-purple-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border after:border-gray-300 after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-purple-600"></div>
                    </label>
                </label>
            </div>

            <button id="goToParticipantsBtn" class="btn-primary w-full">参加者名入力へ</button>
        </div>

        <!-- 2. 参加者登録画面 -->
        <div id="participantsScreen" class="screen">
            <h2 class="text-3xl font-bold mb-8 text-gradient">参加者名入力</h2>

            <div id="participantInputs" class="mb-6 space-y-4">
                <!-- Participant input fields will be added here by JS -->
            </div>

            <div class="flex justify-between mb-8 gap-4">
                <button id="addParticipantBtn" class="btn-secondary flex-1">
                    <svg class="icon" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z" clip-rule="evenodd"></path></svg>
                    <span>参加者追加</span>
                </button>
                <button id="removeParticipantBtn" class="btn-danger flex-1">
                    <svg class="icon" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 011-1h4a1 1 0 110 2H8a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg>
                    <span>参加者削除</span>
                </button>
            </div>

            <button id="startCrushSelectionBtn" class="btn-primary w-full">スタート</button>
        </div>

        <!-- 3. マッチングしたい人選択モード (1人ずつ) -->
        <div id="crushSelectionScreen" class="screen">
            <h2 id="crushSelectionTitle" class="text-3xl font-bold mb-6 text-gradient"></h2>
            <p class="text-lg mb-8 text-gray-700">この画面を<span class="font-bold text-purple-600" id="currentParticipantNameTitle"></span>さんに見せてください</p>

            <button id="iAmParticipantBtn" class="btn-primary w-full mb-8"><span class="font-bold text-purple-600" id="iAmParticipantName"></span>さんであればこのボタンを押してください</button>

            <div id="crushSelectionContent" class="hidden">
                <p class="text-lg mb-4 text-gray-700">マッチングしたい人を選んでください (最大 <span class="font-bold text-purple-600" id="maxCrushCountDisplay"></span>人)</p>
                <div class="flex items-center mb-6">
                    <input type="checkbox" id="noCrushCheckbox" class="h-6 w-6 text-purple-500 rounded-md border-gray-400 focus:ring-purple-500 mr-2">
                    <label for="noCrushCheckbox" class="text-lg font-semibold text-gray-700">マッチングしたい人はいない</label>
                </div>

                <div id="crushList" class="space-y-3 mb-8 text-left">
                    <!-- Crush list will be populated here by JS -->
                </div>

                <button id="finishSelectionBtn" class="btn-primary w-full">選択し終わりました</button>
            </div>
        </div>

        <!-- 4. マッチング成立組数発表 (共通演出画面) -->
        <div id="matchCountScreen" class="screen">
            <h2 id="matchCountTitle" class="text-3xl font-bold mb-8 text-gradient">マッチング成立組数発表！</h2>
            <p class="text-lg mb-4 text-gray-700">ドキドキの結果発表！</p>

            <div class="pachinko-reel-container mb-8">
                <div id="pachinkoReel" class="pachinko-reel"></div>
            </div>

            <p id="matchCountMessage" class="text-2xl font-bold text-gray-800 mb-8"></p>

            <button id="goToResultBtn" class="btn-primary w-full">結果発表へ</button>
        </div>

        <!-- 5. 結果発表モード (1人ずつ) -->
        <div id="resultScreen" class="screen">
            <h2 id="resultTitle" class="text-3xl font-bold mb-6 text-gradient">結果発表</h2>
            <p class="text-lg mb-8 text-gray-700">この画面を<span class="font-bold text-purple-600" id="currentParticipantResultName"></span>さんに見せてください</p>

            <button id="iAmParticipantResultBtn" class="btn-primary w-full mb-8"><span class="font-bold text-purple-600" id="iAmParticipantResultName"></span>さんであればこのボタンを押してください</button>

            <div id="resultContent" class="hidden">
                <button id="confirmResultBtn" class="btn-primary w-full mb-8">確認する</button>
                <div id="matchResultDisplay" class="text-2xl font-bold text-green-600 mb-4">
                    <!-- Match result will be displayed here -->
                </div>
                <!-- 新機能: 一方的にマッチングしたい人数表示 -->
                <div id="unrequitedCrushDisplay" class="text-xl font-bold text-gray-700 mb-8 hidden">
                    <!-- Unrequited crush count will be displayed here -->
                </div>
                <p id="noMatchMessage" class="text-lg text-gray-700 mb-8 hidden">マッチングした人はいませんでした。</p>
                <button id="nextResultBtn" class="btn-primary w-full hidden">次の人へ</button>
            </div>
        </div>

        <!-- Reset Button (always visible for debug/reset) -->
        <button id="resetAppBtn" class="btn-secondary mt-8 w-full">アプリをリセット</button>
    </div>

    <audio id="pingSound" src="https://assets.mixkit.co/sfx/preview/mixkit-positive-interface-click-1113.mp3" preload="auto"></audio>
    <audio id="matchSound" src="https://assets.mixkit.co/sfx/preview/mixkit-game-success-alert-2060.mp3" preload="auto"></audio>
    <audio id="pachinkoSpinSound" src="https://assets.mixkit.co/sfx/preview/mixkit-arcade-game-coin-2155.mp3" preload="auto"></audio>
    <audio id="pachinkoStopSound" src="https://assets.mixkit.co/sfx/preview/mixkit-bonus-earned-in-video-game-2058.mp3" preload="auto"></audio>


    <script>
        // DOM要素の取得
        const settingsScreen = document.getElementById('settingsScreen');
        const participantsScreen = document.getElementById('participantsScreen');
        const crushSelectionScreen = document.getElementById('crushSelectionScreen');
        const matchCountScreen = document.getElementById('matchCountScreen');
        const resultScreen = document.getElementById('resultScreen');

        const goToParticipantsBtn = document.getElementById('goToParticipantsBtn');
        const addParticipantBtn = document.getElementById('addParticipantBtn');
        const removeParticipantBtn = document.getElementById('removeParticipantBtn');
        const startCrushSelectionBtn = document.getElementById('startCrushSelectionBtn');
        const iAmParticipantBtn = document.getElementById('iAmParticipantBtn');
        const finishSelectionBtn = document.getElementById('finishSelectionBtn');
        const goToResultBtn = document.getElementById('goToResultBtn');
        const iAmParticipantResultBtn = document.getElementById('iAmParticipantResultBtn');
        const confirmResultBtn = document.getElementById('confirmResultBtn');
        const nextResultBtn = document.getElementById('nextResultBtn');
        const resetAppBtn = document.getElementById('resetAppBtn');

        const settingsScreenTitle = document.getElementById('settingsScreenTitle'); // 新しいタイトル要素
        const customAppNameInput = document.getElementById('customAppNameInput'); // アプリ名入力フィールド

        const maxCrushesSelect = document.getElementById('maxCrushes');
        const muteToggle = document.getElementById('muteToggle');
        const showUnrequitedCrushesToggle = document.getElementById('showUnrequitedCrushesToggle');

        const participantInputsDiv = document.getElementById('participantInputs');
        const crushSelectionTitle = document.getElementById('crushSelectionTitle');
        const currentParticipantNameTitle = document.getElementById('currentParticipantNameTitle');
        const iAmParticipantNameSpan = document.getElementById('iAmParticipantName');
        const crushSelectionContent = document.getElementById('crushSelectionContent');
        const maxCrushCountDisplay = document.getElementById('maxCrushCountDisplay');
        const noCrushCheckbox = document.getElementById('noCrushCheckbox');
        const crushListDiv = document.getElementById('crushList');
        const pachinkoReel = document.getElementById('pachinkoReel');
        const matchCountMessage = document.getElementById('matchCountMessage');
        const resultTitle = document.getElementById('resultTitle');
        const currentParticipantResultName = document.getElementById('currentParticipantResultName');
        const resultContent = document.getElementById('resultContent');
        const matchResultDisplay = document.getElementById('matchResultDisplay');
        const noMatchMessage = document.getElementById('noMatchMessage');
        const unrequitedCrushDisplay = document.getElementById('unrequitedCrushDisplay');

        const confirmationModal = document.getElementById('confirmationModal');
        const modalMessage = document.getElementById('modalMessage');
        const modalConfirmBtn = document.getElementById('modalConfirmBtn');
        const modalCancelBtn = document.getElementById('modalCancelBtn');

        const pingSound = document.getElementById('pingSound');
        const matchSound = document.getElementById('matchSound');
        const pachinkoSpinSound = document.getElementById('pachinkoSpinSound');
        const pachinkoStopSound = document.getElementById('pachinkoStopSound');

        // アプリケーションの状態を管理するオブジェクト
        let appState = {
            settings: {
                appName: '', // カスタムアプリ名
                maxCrushes: 1,
                muted: false,
                showUnrequitedCrushes: false,
                language: 'ja', // 日本語のみに固定
            },
            participants: [], // { id: string, name: string, crushes: string[] }
            matches: [], // { p1Id: string, p2Id: string }
            currentParticipantIndex: 0,
            currentResultIndex: 0,
            totalMatchesFound: 0,
        };

        // テキストデータ (日本語のみ)
        const texts = {
            defaultAppName: "片想いマッチング", // デフォルトアプリ名
            // 修正: 「デートに行ってみたい人数」から「選択可能人数」に変更
            maxCrushesLabel: "選択可能人数",
            personCount: "{{count}}人",
            // 汎用的な表現に統一
            showUnrequitedCrushesLabel: "あなたに一方的にマッチングしたい人を表示する",
            muteLabel: "ミュート",
            goToParticipantsBtn: "参加者名入力へ",
            participantsTitle: "参加者名入力",
            addParticipantBtn: "参加者追加",
            addParticipantBtnText: "参加者追加",
            removeParticipantBtn: "参加者削除",
            removeParticipantBtnText: "参加者削除",
            startBtn: "スタート",
            // 修正: 「デートに行ってみたい選択」から「マッチングしたい人選択」に変更
            crushSelectionTitle: "マッチングしたい人選択", // ここは固定で「マッチングしたい人選択」
            showScreenTo: "この画面を<span class='font-bold text-purple-600'>{{name}}</span>さんに見せてください",
            iAmParticipantBtn: "<span class='font-bold text-purple-600'>{{name}}</span>さんであればこのボタンを押してください",
            // 修正: 「デートに行ってみたい人を選んでください」から「マッチングしたい人を選んでください」に変更
            selectCrushes: "マッチングしたい人を選んでください (最大 <span class='font-bold text-purple-600'>{{count}}</span>人)",
            // 修正: 「デートに行ってみたい人はいない」から「マッチングしたい人はいない」に変更
            noCrushCheckbox: "マッチングしたい人はいない",
            finishSelectionBtn: "選択し終わりました",
            // 「両思い」を「マッチング」に統一
            matchCountTitle: "マッチング成立組数発表！",
            excitingResults: "ドキドキの結果発表！",
            goToResultBtn: "結果発表へ",
            resultTitle: "結果発表",
            confirmResultBtn: "確認する",
            // 「両思い」を「マッチング」に統一
            noMutualCrush: "マッチングした人はいませんでした。",
            // 汎用的な表現に統一
            unrequitedCrushCount: "あなたに一方的にマッチングしたい人があと {{count}} 人います。",
            nextPersonBtn: "次の人へ",
            resetAppBtn: "アプリをリセット",
            modalConfirm: "この内容で確定しますか？",
            modalReset: "アプリのデータを全てリセットしますか？",
            modalMinParticipants: "参加者は最低2人必要です。",
            modalMaxParticipants: "参加者は最大10人までです。",
            modalEmptyNames: "全ての参加者の名前を入力してください。",
            modalMaxCrushes: "選択できるのは最大{{count}}人までです。",
            modalAllResultsDone: "全員の結果発表が終わりました。アプリをリセットしますか？",
            yes: "はい",
            no: "いいえ",
            enterNamePlaceholder: "名前を入力",
            // 「両思い」を「マッチング」に統一
            youAndMutual: "あなたと{{name}}さん、マッチングしました！💖"
        };

        /**
         * 画面を切り替える関数
         * @param {HTMLElement} screenToShow - 表示する画面のDOM要素
         */
        function showScreen(screenToShow) {
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
            });
            screenToShow.classList.add('active');
            updateTextContent(); // 画面切り替え時にテキストを更新
        }

        /**
         * ユニークIDを生成するヘルパー関数
         * @returns {string} ユニークID
         */
        function generateUniqueId() {
            return Math.random().toString(36).substring(2, 11);
        }

        /**
         * 音を再生する関数
         * @param {HTMLAudioElement} sound - 再生するAudio要素
         */
        function playSound(sound) {
            if (!appState.settings.muted) {
                sound.currentTime = 0;
                sound.play().catch(e => console.error("Failed to play sound:", e));
            }
        }

        /**
         * テキストコンテンツを現在の言語設定に基づいて更新する
         */
        function updateTextContent() {
            // アプリのメインタイトルを更新
            settingsScreenTitle.textContent = appState.settings.appName || texts.defaultAppName;

            // data-i18n-keyを持つ要素を更新
            document.querySelectorAll('[data-i18n-key]').forEach(element => {
                const key = element.dataset.i18nKey;
                
                // 動的な値を含む要素はtextContentを直接更新しない
                // crushSelectionTitleはここで更新せず、startCrushSelectionForCurrentParticipantで更新
                if (key === "showScreenTo" || key === "iAmParticipantBtn" || key === "selectCrushes" || key === "crushSelectionTitle") {
                    return;
                }
                
                if (element.tagName === 'INPUT' && element.placeholder) {
                    element.placeholder = texts[key];
                } else if (element.tagName === 'OPTION' && element.closest('select') && element.closest('select').id === 'maxCrushes') {
                    element.textContent = texts['personCount'].replace('{{count}}', element.value);
                } else if (element.tagName === 'BUTTON' && element.querySelector('span')) {
                    element.querySelector('span').textContent = texts[key];
                } else {
                    element.textContent = texts[key];
                }
            });

            // 参加者入力のプレースホルダーを更新
            document.querySelectorAll('.participant-name-input').forEach(input => {
                input.placeholder = texts['enterNamePlaceholder'];
            });

            // モーダルボタンのテキストを更新
            document.getElementById('modalConfirmBtn').textContent = texts['yes'];
            document.getElementById('modalCancelBtn').textContent = texts['no'];
        }


        /**
         * 確認モーダルを表示する
         * @param {string} messageKey - モーダルに表示するメッセージのキー
         * @param {object} args - メッセージに埋め込む引数
         * @returns {Promise<boolean>} ユーザーが「はい」を押したらtrue、それ以外はfalse
         */
        function showConfirmationModal(messageKey, args = {}) {
            return new Promise(resolve => {
                let message = texts[messageKey];
                for (const argKey in args) {
                    message = message.replace(new RegExp(`\\{\\{${argKey}\\}\\}`, 'g'), args[argKey]);
                }
                modalMessage.textContent = message;
                confirmationModal.classList.add('active');

                const handleConfirm = () => {
                    confirmationModal.classList.remove('active');
                    modalConfirmBtn.removeEventListener('click', handleConfirm);
                    modalCancelBtn.removeEventListener('click', handleCancel);
                    resolve(true);
                };

                const handleCancel = () => {
                    confirmationModal.classList.remove('active');
                    modalConfirmBtn.removeEventListener('click', handleConfirm);
                    modalCancelBtn.removeEventListener('click', handleCancel);
                    resolve(false);
                };

                modalConfirmBtn.addEventListener('click', handleConfirm);
                modalCancelBtn.addEventListener('click', handleCancel);
            });
        }

        // --- 1. 設定画面のロジック ---
        // アプリ名入力フィールドのイベントリスナー
        customAppNameInput.addEventListener('input', (e) => {
            appState.settings.appName = e.target.value;
            updateTextContent(); // タイトルを即時更新
        });

        maxCrushesSelect.addEventListener('change', (e) => {
            appState.settings.maxCrushes = parseInt(e.target.value);
            updateTextContent();
        });

        muteToggle.addEventListener('change', (e) => {
            appState.settings.muted = e.target.checked;
        });

        showUnrequitedCrushesToggle.addEventListener('change', (e) => {
            appState.settings.showUnrequitedCrushes = e.target.checked;
        });

        goToParticipantsBtn.addEventListener('click', () => {
            if (appState.participants.length === 0) {
                appState.participants.push({ id: generateUniqueId(), name: '', crushes: [] });
                appState.participants.push({ id: generateUniqueId(), name: '', crushes: [] });
            }
            renderParticipantInputs();
            showScreen(participantsScreen);
        });

        // --- 2. 参加者登録画面のロジック ---
        /**
         * 参加者入力フィールドをレンダリングする
         */
        function renderParticipantInputs() {
            participantInputsDiv.innerHTML = '';
            appState.participants.forEach((participant, index) => {
                const div = document.createElement('div');
                div.className = 'flex items-center gap-2';
                div.innerHTML = `
                    <label class="label-text flex-shrink-0">${texts['participantsTitle'].replace('参加者名入力', '')} ${index + 1}:</label>
                    <input type="text" value="${participant.name}" data-id="${participant.id}" placeholder="${texts['enterNamePlaceholder']}" class="input-field participant-name-input flex-grow">
                `;
                participantInputsDiv.appendChild(div);
            });

            document.querySelectorAll('.participant-name-input').forEach(input => {
                input.addEventListener('input', (e) => {
                    const id = e.target.dataset.id;
                    const participant = appState.participants.find(p => p.id === id);
                    if (participant) {
                        participant.name = e.target.value;
                    }
                });
            });
        }

        addParticipantBtn.addEventListener('click', () => {
            if (appState.participants.length >= 10) {
                showConfirmationModal('modalMaxParticipants');
                return;
            }
            appState.participants.push({ id: generateUniqueId(), name: '', crushes: [] });
            renderParticipantInputs();
        });

        removeParticipantBtn.addEventListener('click', async () => {
            if (appState.participants.length <= 2) {
                await showConfirmationModal('modalMinParticipants');
                return;
            }
            const confirmed = await showConfirmationModal('modalConfirm');
            if (confirmed) {
                appState.participants.pop();
                renderParticipantInputs();
            }
        });

        startCrushSelectionBtn.addEventListener('click', async () => {
            const emptyNames = appState.participants.filter(p => p.name.trim() === '');
            if (emptyNames.length > 0) {
                await showConfirmationModal('modalEmptyNames');
                return;
            }
            if (appState.participants.length < 2) {
                await showConfirmationModal('modalMinParticipants');
                return;
            }

            appState.participants.forEach(p => p.crushes = []);
            appState.currentParticipantIndex = 0;
            appState.matches = [];

            startCrushSelectionForCurrentParticipant();
            showScreen(crushSelectionScreen);
        });

        // --- 3. マッチングしたい人選択モード (1人ずつ) ---
        /**
         * 現在の参加者の選択画面を設定する
         */
        function startCrushSelectionForCurrentParticipant() {
            const currentParticipant = appState.participants[appState.currentParticipantIndex];

            if (!currentParticipant) {
                calculateMatches();
                showScreen(matchCountScreen);
                startPachinkoAnimation();
                return;
            }

            playSound(pingSound);
            // 修正: アプリのテーマ名を表示
            crushSelectionTitle.textContent = appState.settings.appName || texts.defaultAppName;
            
            // 動的なテキストを直接設定
            document.querySelector('#crushSelectionScreen p').innerHTML = texts['showScreenTo'].replace('{{name}}', currentParticipant.name);
            document.querySelector('#iAmParticipantBtn').innerHTML = texts['iAmParticipantBtn'].replace('{{name}}', currentParticipant.name);
            document.querySelector('#crushSelectionContent p').innerHTML = texts['selectCrushes'].replace('{{count}}', appState.settings.maxCrushes);

            crushSelectionContent.classList.add('hidden');
            iAmParticipantBtn.classList.remove('hidden');

            renderCrushList(currentParticipant.id);
            noCrushCheckbox.checked = false;
            noCrushCheckbox.disabled = false;
        }

        iAmParticipantBtn.addEventListener('click', () => {
            iAmParticipantBtn.classList.add('hidden');
            crushSelectionContent.classList.remove('hidden');
        });

        noCrushCheckbox.addEventListener('change', (e) => {
            const checkboxes = document.querySelectorAll('#crushList input[type="checkbox"]');
            checkboxes.forEach(cb => {
                cb.checked = false;
                cb.disabled = e.target.checked;
            });
        });

        /**
         * 選択リストをレンダリングする
         * @param {string} currentParticipantId - 現在の参加者のID
         */
        function renderCrushList(currentParticipantId) {
            crushListDiv.innerHTML = '';
            appState.participants.forEach(p => {
                if (p.id === currentParticipantId) return;

                const label = document.createElement('label');
                label.className = 'checkbox-container';
                label.innerHTML = `
                    <span class="text-lg font-medium text-gray-700">${p.name}</span>
                    <input type="checkbox" data-id="${p.id}" class="crush-checkbox">
                `;
                crushListDiv.appendChild(label);
            });

            document.querySelectorAll('.crush-checkbox').forEach(checkbox => {
                checkbox.addEventListener('change', (e) => {
                    const checkedCount = document.querySelectorAll('.crush-checkbox:checked').length;
                    if (checkedCount > appState.settings.maxCrushes) {
                        e.target.checked = false;
                        showConfirmationModal('modalMaxCrushes', { count: appState.settings.maxCrushes });
                    } else {
                        noCrushCheckbox.checked = false;
                        noCrushCheckbox.disabled = (checkedCount > 0);
                    }
                });
            });
        }

        finishSelectionBtn.addEventListener('click', async () => {
            const currentParticipant = appState.participants[appState.currentParticipantIndex];
            if (!currentParticipant) return;

            currentParticipant.crushes = [];
            if (!noCrushCheckbox.checked) {
                document.querySelectorAll('.crush-checkbox:checked').forEach(checkbox => {
                    currentParticipant.crushes.push(checkbox.dataset.id);
                });
            }

            const confirmed = await showConfirmationModal('modalConfirm');
            if (confirmed) {
                appState.currentParticipantIndex++;
                startCrushSelectionForCurrentParticipant();
            }
        });

        // --- マッチング計算ロジック ---
        function calculateMatches() {
            appState.matches = [];
            const participantsMap = new Map(appState.participants.map(p => [p.id, p]));

            for (let i = 0; i < appState.participants.length; i++) {
                const p1 = appState.participants[i];
                for (const crushId of p1.crushes) {
                    const p2 = participantsMap.get(crushId);
                    if (p2 && p2.crushes.includes(p1.id)) {
                        const sortedMatchIds = [p1.id, p2.id].sort();
                        const newMatch = { p1Id: sortedMatchIds[0], p2Id: sortedMatchIds[1] };

                        const isDuplicate = appState.matches.some(m =>
                            m.p1Id === newMatch.p1Id && m.p2Id === newMatch.p2Id
                        );
                        if (!isDuplicate) {
                            appState.matches.push(newMatch);
                        }
                    }
                }
            }
            appState.totalMatchesFound = appState.matches.length;
        }

        // --- 4. マッチング成立組数発表 (共通演出画面) ---
        function startPachinkoAnimation() {
            playSound(pachinkoSpinSound);
            pachinkoReel.textContent = '';
            pachinkoReel.classList.remove('pachinko-reel-final');
            pachinkoReel.classList.add('active');

            let count = 0;
            const interval = setInterval(() => {
                pachinkoReel.textContent = Math.floor(Math.random() * 10).toString();
                count++;
                if (count > 30) {
                    clearInterval(interval);
                    stopPachinkoAnimation();
                }
            }, 80);
        }

        function stopPachinkoAnimation() {
            playSound(pachinkoStopSound);
            pachinkoReel.classList.remove('active');
            setTimeout(() => {
                pachinkoReel.textContent = appState.totalMatchesFound.toString();
                pachinkoReel.classList.add('pachinko-reel-final');
                
                if (appState.totalMatchesFound > 0) {
                    matchCountMessage.textContent = texts['matchCountTitle'].replace('！', '') + `！${appState.totalMatchesFound}組のマッチングが成立しました！`;
                } else {
                    matchCountMessage.textContent = texts['noMutualCrush'];
                }
            }, 300);
        }

        goToResultBtn.addEventListener('click', () => {
            appState.currentResultIndex = 0;
            startResultAnnouncementForCurrentParticipant();
            showScreen(resultScreen);
        });

        // --- 5. 結果発表モード (1人ずつ) ---
        /**
         * 現在の参加者の結果発表画面を設定する
         */
        function startResultAnnouncementForCurrentParticipant() {
            const currentParticipant = appState.participants[appState.currentResultIndex];

            if (!currentParticipant) {
                showConfirmationModal('modalAllResultsDone').then(confirmed => {
                    if (confirmed) {
                        resetApp();
                    } else {
                        showScreen(settingsScreen);
                    }
                });
                return;
            }

            playSound(pingSound);
            resultTitle.textContent = texts['resultTitle'];
            
            // 動的なテキストを直接設定
            document.querySelector('#resultScreen p').innerHTML = texts['showScreenTo'].replace('{{name}}', currentParticipant.name);
            document.querySelector('#iAmParticipantResultBtn').innerHTML = texts['iAmParticipantBtn'].replace('{{name}}', currentParticipant.name);


            resultContent.classList.add('hidden');
            iAmParticipantResultBtn.classList.remove('hidden');

            confirmResultBtn.classList.remove('hidden');

            matchResultDisplay.textContent = '';
            noMatchMessage.classList.add('hidden');
            unrequitedCrushDisplay.classList.add('hidden');
            nextResultBtn.classList.add('hidden');
        }

        iAmParticipantResultBtn.addEventListener('click', () => {
            iAmParticipantResultBtn.classList.add('hidden');
            resultContent.classList.remove('hidden');
        });

        confirmResultBtn.addEventListener('click', () => {
            const currentParticipant = appState.participants[appState.currentResultIndex];
            if (!currentParticipant) return;

            let foundMatch = false;
            for (const match of appState.matches) {
                if (match.p1Id === currentParticipant.id) {
                    const matchedParticipant = appState.participants.find(p => p.id === match.p2Id);
                    if (matchedParticipant) {
                        matchResultDisplay.textContent = texts['youAndMutual'].replace('{{name}}', matchedParticipant.name);
                        playSound(matchSound);
                        foundMatch = true;
                        break;
                    }
                } else if (match.p2Id === currentParticipant.id) {
                    const matchedParticipant = appState.participants.find(p => p.id === match.p1Id);
                    if (matchedParticipant) {
                        matchResultDisplay.textContent = texts['youAndMutual'].replace('{{name}}', matchedParticipant.name);
                        playSound(matchSound);
                        foundMatch = true;
                        break;
                    }
                }
            }

            if (!foundMatch) {
                matchResultDisplay.textContent = '';
                noMatchMessage.classList.remove('hidden');
            }

            if (appState.settings.showUnrequitedCrushes) {
                let unrequitedCrushCount = 0;
                for (const otherParticipant of appState.participants) {
                    if (otherParticipant.id === currentParticipant.id) continue;

                    if (otherParticipant.crushes.includes(currentParticipant.id)) {
                        const isMutual = appState.matches.some(match =>
                            (match.p1Id === currentParticipant.id && match.p2Id === otherParticipant.id) ||
                            (match.p1Id === otherParticipant.id && match.p2Id === currentParticipant.id)
                        );
                        if (!isMutual) {
                            unrequitedCrushCount++;
                        }
                    }
                }

                if (unrequitedCrushCount > 0) {
                    unrequitedCrushDisplay.textContent = texts['unrequitedCrushCount'].replace('{{count}}', unrequitedCrushCount);
                    unrequitedCrushDisplay.classList.remove('hidden');
                } else {
                    unrequitedCrushDisplay.classList.add('hidden');
                }
            } else {
                unrequitedCrushDisplay.classList.add('hidden');
            }

            confirmResultBtn.classList.add('hidden');
            nextResultBtn.classList.remove('hidden');
        });

        nextResultBtn.addEventListener('click', async () => {
            const confirmed = await showConfirmationModal('modalConfirm');
            if (confirmed) {
                appState.currentResultIndex++;
                startResultAnnouncementForCurrentParticipant();
            }
        });

        // --- アプリのリセット機能 ---
        function resetApp() {
            appState = {
                settings: {
                    appName: '', // アプリ名をリセット
                    maxCrushes: 1,
                    muted: false,
                    showUnrequitedCrushes: false,
                    language: 'ja',
                },
                participants: [],
                matches: [],
                currentParticipantIndex: 0,
                currentResultIndex: 0,
                totalMatchesFound: 0,
            };
            customAppNameInput.value = ''; // 入力フィールドもクリア
            maxCrushesSelect.value = 1;
            muteToggle.checked = false;
            showUnrequitedCrushesToggle.checked = false;
            participantInputsDiv.innerHTML = '';
            showScreen(settingsScreen);
        }

        resetAppBtn.addEventListener('click', async () => {
            const confirmed = await showConfirmationModal('modalReset');
            if (confirmed) {
                resetApp();
            }
        });

        // アプリケーション起動時の初期化
        window.onload = () => {
            resetApp(); // 初期状態でリセット
            // customAppNameInputのplaceholderを初期設定
            customAppNameInput.placeholder = texts.defaultAppName;
            updateTextContent(); // 初期表示時にテキストを更新
        };
    </script>
</body>
</html>
